# Developer Onboarding

Welcome to the agency. You're about to learn a completely different way of building software than what most tutorials teach. Most development shops treat every new project like starting from scratch—they rebuild the same buttons, forms, and layouts over and over. We don't do that. We build once and reuse everywhere. This isn't laziness, it's strategy. Every component you create here becomes part of a growing library that makes the next project faster than the last. After five projects, we're building applications ten times faster than competitors who keep reinventing the wheel. This is our competitive advantage, and you're now part of building it.

The first principle you need to understand is ownership. We don't use pre-built component libraries like Shadcn or Material UI, even though they seem convenient at first. Think of it like this: would you rather rent an apartment where the landlord controls everything, or own a house you can modify however you want? Third-party libraries are like renting. They make decisions for you about what a button should look like, how a form should behave, and what features are available. When you work with fifty different clients who all want different things, those decisions become walls you can't break through. We own our components from the ground up, which means we control everything and can adapt to any client's needs without fighting someone else's assumptions.

Our codebase is built on what we call a flat component architecture. This means every UI component lives in one folder called "app/components" with a simple PascalCase name like Button.tsx or ItemCard.tsx. No subfolders, no nesting, no hunting through ten levels of directories to find what you need. When you open that folder, you see the entire UI of the application in thirty-four component files. Each file is self-contained—everything the component needs is right there inside it. This isn't just about organization, it's about your sanity. As a beginner, you won't spend days trying to figure out where things are or how pieces connect. You open one file, and you see everything that component does.

We build with design tokens, which is a fancy way of saying we use CSS custom properties for all our styling decisions. Here's why this matters: when Client A wants their application in blue and Client B wants theirs in green, we don't rewrite any components. We just swap one CSS file for another. Same buttons, same forms, same layouts—completely different look. This is what makes us so fast. While other agencies are customizing components for each client and breaking things in the process, we're just changing a theme file and shipping. You'll learn to think in tokens: not "make this button blue," but "make this button use the primary color token." That small mental shift unlocks incredible reusability.

Everything we write is explicitly typed with TypeScript. This means every component has a clear interface that tells you exactly what props it accepts and what types those props should be. As a beginner, this is your safety net. You'll never wonder "what does this component need?" or "did I pass the wrong type of data?" TypeScript and your code editor will tell you immediately with autocomplete and error messages. This might feel like extra work at first, but it's actually saving you hours of debugging. Explicit types are documentation that never gets out of sync with the code because the computer enforces it.

We build for portability, which means components should work anywhere with zero modifications. Every component we write should be copy-paste ready—you should be able to take it from Project A, drop it into Project B, and have it work immediately. This is only possible because each component is self-contained and uses design tokens instead of hard-coded values. When you write a component here, you're not writing it for one project. You're writing it for the next twenty projects. That's a different mindset than what most tutorials teach. It means thinking ahead, avoiding shortcuts that only work in one context, and building systems instead of features.

The tech stack we use isn't trendy—it's timeless. We build on Next.js, React, TypeScript, Tailwind CSS, and standard CSS. These technologies will be here in 2030 because they're built on web standards, not hype. When you learn to build this way, you're not learning tools that will be obsolete next year. You're learning foundations that will carry your entire career. We don't chase the newest framework or the hottest library. We ask: will this exist in five years? Will junior developers understand this? Can we depend on this? If the answer is no, we don't use it. This gives you stability as a learner and durability as a professional.

Every project we do feeds back into the component library. When you build a new feature for Client A, you're not just completing a task—you're potentially adding a new component that makes Client B's project easier. When you improve an existing component, that improvement benefits every project using it. This creates compound growth. The first project takes normal time. The tenth project is dramatically faster because we already have most of what we need. The fiftieth project feels like assembling LEGO blocks. This is why our profit margins keep increasing while our delivery time keeps decreasing. You're not just learning to code—you're learning to build systems that make you exponentially more efficient over time.

We use optimistic updates everywhere, which makes our applications feel instant even when they're talking to servers. When a user clicks "save," we immediately update the UI as if it worked, then fix it later if something went wrong. This creates a desktop-quality experience in a web application. As you're learning, this pattern will seem magical—the application feels so responsive even though data is being sent across the internet. You'll learn how we achieve this with React Query, how we handle errors gracefully, and how we make network delays invisible to users. This attention to perceived performance is what separates good applications from great ones.

The last thing to understand is that our codebase is our onboarding documentation. Unlike companies where new developers face weeks of confusion trying to understand custom abstractions and implicit dependencies, you can learn our entire system by reading thirty-four component files. Each one is explicit, typed, and self-contained. There are no hidden utilities, no magical helpers, no clever abstractions to decode. This means you can be productive on day one. You'll make mistakes, but they'll be small and local, not cascade through mysterious dependencies. As you grow, you'll understand why we built it this way: clarity and simplicity scale better than cleverness. Welcome to the team. Now go read some components and start building.